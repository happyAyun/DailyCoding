# 1699번 제곱수의 합

[백준 1699번 제곱수의 합 문제](https://www.acmicpc.net/problem/1699) 

- 이렇게 하면 틀림!!
  - sqrt() 함수를 이용하여 나온 정수를 빼주는 while문으로 작성하였다.
  - 이렇게 풀라고 낸 문제는 아니겠지 하면서도 채점을 하였지만, 역시다 **틀렸습니다.**
- 문제의 풀이는 꼭 큰 수의 제곱으로 작성된다고 제곱수 항의 최소 개수가 출력되어지는 것은 아니다.
- **12의 예에서 3^2 + 1 + 1 + 1 일 때 4개의 항보다 2^2 + 2^2 + 2^2 일 때 3개의 항이 더 최소의 개수이다.** 라는 것이다. [ 출처 ](https://mtoc.tistory.com/38) 에서 도움을 받아 풀이하였다.
- 맞는 풀이는 배열에 우선 입력받은 수 n까지 1의 제곱으로 들어갈 수 있는 수, 즉 자기 자신의 값을 넣어준다. 먼저 최대 항의 수를 넣어주는 것이다.
- 그리고 이중 for문을 이용해서 최솟값을 찾는 연산을 통해 점점 최솟값으로 배열의 값을 갱신하여주면 된다.

- 이중 for문의 시작은 2부터 시작한다. 1은 이미 제곱이 가능한 수가 1밖에 존재하지 않기 때문에 최소의 값이 완성된 상태이기 때문이다.
- 따라서 첫번째 위 for문에서는 2부터 n까지이고, 두번째 안쪽 for문은 변수의 값이 2부터 시작해서 변수의 제곱이 위의 for문의 값보다 작거나 값다면 연산을 시작한다.
- 이 연산이 의미하는 것은 해당 제곱보다 크거나 같을 경우 해당 제곱을 n의 제곱항으로 포함하여  해당 변수의 값의 수에서 최소의 제곱항을 만드는 과정이라고 할 수 있다.
-  ` dp[i - j * j] + 1` 부분에서 1을 더해주는 이유는 제곱항을 뺀 값의 나머지 제곱항에 현재 j*j의 제곱항 하나를 더해주는 것이다.

```c++
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <vector>
#include <queue>
#include <cmath>
using namespace std;
int dp[100001];
int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        dp[i] = i;
    for (int i = 2; i <= n; i++)
    {
        for (int j = 2; j * j <= i; j++)
            dp[i] = min(dp[i], dp[i - j * j] + 1);
    }
    cout << dp[n] << '\n';
    return 0;
}

```

